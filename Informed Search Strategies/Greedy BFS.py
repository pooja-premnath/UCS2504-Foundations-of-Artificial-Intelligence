'''node_weight={}
n=int(input("Enter the number of nodes"))

for i in range (n):
    node=input("Enter the node")
    weight=int(input("Enter the node weight"))
    node_weight[node]=weight

neighbors={}
heuristic_values={}
node_list=list(node_weight.keys())

for i in node_list:
    print("Node: ", i)
    num_neighbors=int(input("Enter the number of neighbors"))
    neighbor_list=[]
    for j in range(num_neighbors):
        new_node=input("Enter the neighbor")
        neighbor_list.append(new_node)

        heuristic=int(input("Enter the cost to travelling to this node"))
        heuristic_values[(i,new_node)]=heuristic

    neighbors[i]=neighbor_list



print(neighbors)
print(heuristic_values)'''


#sample input generated by the above code
neighbors={'A': ['B', 'C', 'D'], 'B': ['E'], 'C': ['F', 'G'], 'D': ['G'], 'E': ['H'], 'F': ['H'], 'G': ['H'], 'H': []}
heuristic={('A', 'B'): 4, ('A', 'C'): 4, ('A', 'D'): 5, ('B', 'E'): 6, ('C', 'F'): 3, ('C', 'G'): 2, ('D', 'G'): 1, ('E', 'H'): 9, ('F', 'H'): 2, ('G', 'H'): 1}
node_weight={'A':4, 'B':4, 'C':3, 'D':5, 'E':7, 'F':2, 'G':1, 'H':9}



initial_state='A'
goal_state='H'
current_state='A'
cost=0

path=[]


path.append(current_state)
while current_state!=goal_state:

    print("Current state", current_state)

    #get a list of the neighbors of the current node from the neighbors dictionary
    current_neighbors=neighbors[current_state]
    print("Current Neighbors: ", current_neighbors)
    if goal_state in current_neighbors:
        break

    if len(current_neighbors)==1:

        print("in hereeee")
        min_neighbor=current_neighbors[0]
        min_neighbor_cost=node_weight[current_neighbors[0]]
        path.append(min_neighbor)
        
        
    else:
        #Initialize the neighbor node with minimum weight to be the first of these neighbors
        min_neighbor= current_state
        min_neighbor_cost=node_weight[current_neighbors[0]]
    

    
        for i in current_neighbors:
        
            i_cost=node_weight[i]

        
            if i_cost<=min_neighbor_cost:
                min_neighbor_cost=i_cost
                min_neighbor=i

        path.append(min_neighbor)

    #cost computation
    cost+= heuristic[(current_state, min_neighbor)]
    print("Current cost: ", cost)
    current_state=min_neighbor


cost += heuristic[(current_state, goal_state)]
path.append(goal_state)
print("Path to Goal State", path)
print("Total cost: ", cost)
